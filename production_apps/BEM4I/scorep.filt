SCOREP_REGION_NAMES_BEGIN
EXCLUDE
Eigen::SparseMatrix<_Scalar, _Options, _Index>& Eigen::SparseMatrix<_Scalar, _Flags, _StorageIndex>::operator=(const Eigen::SparseMatrixBase<OtherDerived>&) [with OtherDerived = Eigen::SparseMatrix<std::complex<double>, 1, long int>; _Scalar = std::complex<double>; int _Options = 0; _Index = long int]
SC bem4i::Vector<LO, SC>::dot(const bem4i::Vector<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
bem4i::BEBilinearForm<LO, SC>::BEBilinearForm() [with LO = long int; SC = std::complex<double>]
bem4i::BEBilinearForm<LO, SC>::~BEBilinearForm() [with LO = long int; SC = std::complex<double>]
bem4i::BEBilinearFormHelmholtz1Layer<LO, SC>::BEBilinearFormHelmholtz1Layer(bem4i::BESpace<LO, SC>*, int*, SC, bem4i::quadratureType, int*) [with LO = long int; SC = std::complex<double>]
bem4i::BEBilinearFormHelmholtz1Layer<LO, SC>::~BEBilinearFormHelmholtz1Layer() [with LO = long int; SC = std::complex<double>]
bem4i::BEBilinearFormHelmholtz2Layer<LO, SC>::BEBilinearFormHelmholtz2Layer(bem4i::BESpace<LO, SC>*, int*, SC, bem4i::quadratureType, int*) [with LO = long int; SC = std::complex<double>]
bem4i::BEBilinearFormHelmholtz2Layer<LO, SC>::~BEBilinearFormHelmholtz2Layer() [with LO = long int; SC = std::complex<double>]
bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::BEIntegrator() [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::~BEIntegrator() [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
bem4i::BEIntegratorHelmholtz<LO, SC>::BEIntegratorHelmholtz(bem4i::BESpace<LO, SC>*, int*, SC, bem4i::quadratureType, int*) [with LO = long int; SC = std::complex<double>]
bem4i::BEIntegratorHelmholtz<LO, SC>::~BEIntegratorHelmholtz() [with LO = long int; SC = std::complex<double>]
bem4i::BESpace<LO, SC>::BESpace(bem4i::SurfaceMesh3D<LO, SC>*, bem4i::basisType, bem4i::basisType) [with LO = long int; SC = std::complex<double>]
bem4i::BESpace<LO, SC>::~BESpace() [with LO = long int; SC = std::complex<double>]
bem4i::FullMatrix<LO2, SC2>::FullMatrix(LO, LO, bool, bool) [with LO = long int; SC = double]
bem4i::FullMatrix<LO2, SC2>::FullMatrix(LO, LO, bool, bool) [with LO = long int; SC = std::complex<double>]
bem4i::FullMatrix<LO2, SC2>::~FullMatrix() [with LO = long int; SC = double]
bem4i::FullMatrix<LO2, SC2>::~FullMatrix() [with LO = long int; SC = std::complex<double>]
bem4i::IdentityOperator<LO3, SC3>::IdentityOperator(bem4i::BESpace<LO, SC>*) [with LO = long int; SC = std::complex<double>]
bem4i::IdentityOperator<LO3, SC3>::~IdentityOperator() [with LO = long int; SC = std::complex<double>]
bem4i::Matrix<LO, SC>::Matrix() [with LO = long int; SC = double]
bem4i::Matrix<LO, SC>::Matrix() [with LO = long int; SC = std::complex<double>]
bem4i::Matrix<LO, SC>::~Matrix() [with LO = long int; SC = double]
bem4i::Matrix<LO, SC>::~Matrix() [with LO = long int; SC = std::complex<double>]
bem4i::Mesh<LO, SC>::Mesh() [with LO = long int; SC = std::complex<double>]
bem4i::Mesh<LO, SC>::~Mesh() [with LO = long int; SC = std::complex<double>]
bem4i::SparseMatrix<LO, SC, storage>::SparseMatrix() [with LO = long int; SC = std::complex<double>; int storage = 0]
bem4i::SparseMatrix<LO, SC, storage>::~SparseMatrix() [with LO = long int; SC = std::complex<double>; int storage = 0]
bem4i::SurfaceMesh3D<LO, SC>::SCVT bem4i::SurfaceMesh3D<LO, SC>::l2RelativeErrorConst(const bem4i::Vector<LO, SC>&, int, SC) const [with LO = long int; SC = std::complex<double>]
bem4i::SurfaceMesh3D<LO, SC>::SurfaceMesh3D() [with LO = long int; SC = std::complex<double>]
bem4i::SurfaceMesh3D<LO, SC>::~SurfaceMesh3D() [with LO = long int; SC = std::complex<double>]
bem4i::Vector<LO, SC>::SCVT bem4i::Vector<LO, SC>::norm2() const [with LO = long int; SC = double]
bem4i::Vector<LO, SC>::SCVT bem4i::Vector<LO, SC>::norm2() const [with LO = long int; SC = std::complex<double>]
bem4i::Vector<LO, SC>::Vector(LO, SC*, bool) [with LO = long int; SC = double]
bem4i::Vector<LO, SC>::Vector(LO, bool) [with LO = long int; SC = double]
bem4i::Vector<LO, SC>::Vector(LO, bool) [with LO = long int; SC = std::complex<double>]
bem4i::Vector<LO, SC>::Vector(const bem4i::Vector<LO, SC>&) [with LO = long int; SC = std::complex<double>]
bem4i::Vector<LO, SC>::~Vector() [with LO = long int; SC = double]
bem4i::Vector<LO, SC>::~Vector() [with LO = long int; SC = std::complex<double>]
bool bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::areElementsDisjoint(LO, LO, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT) const [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
void Eigen::SparseMatrix<_Scalar, _Flags, _StorageIndex>::collapseDuplicates(DupFunctor) [with DupFunctor = Eigen::internal::scalar_sum_op<std::complex<double>, std::complex<double> >; _Scalar = std::complex<double>; int _Options = 1; _Index = long int]
void Eigen::SparseMatrix<_Scalar, _Flags, _StorageIndex>::setFromTriplets(const InputIterators&, const InputIterators&) [with InputIterators = __gnu_cxx::__normal_iterator<Eigen::Triplet<std::complex<double>, long int>*, std::vector<Eigen::Triplet<std::complex<double>, long int>, std::allocator<Eigen::Triplet<std::complex<double>, long int> > > >; _Scalar = std::complex<double>; int _Options = 0; _Index = long int]
void Eigen::internal::check_for_aliasing(const Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long int>, Eigen::Matrix<long int, -1, 1, 0, -1, 1> >]
void Eigen::internal::check_for_aliasing(const Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<double>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<std::complex<double>, -1, 1>]
void Eigen::internal::check_for_aliasing(const Dst&, const Src&) [with Dst = Eigen::Matrix<long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long int>, Eigen::Matrix<long int, -1, 1, 0, -1, 1> >]
void Eigen::internal::check_for_aliasing(const Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<double>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<double>, std::complex<double> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<double>, -1, 1>, 0, Eigen::Stride<0, 0> > >]
void Eigen::internal::ignore_unused_variable(const T&) [with T = long int]
void Eigen::internal::set_from_triplets(const InputIterator&, const InputIterator&, SparseMatrixType&, DupFunctor) [with InputIterator = __gnu_cxx::__normal_iterator<Eigen::Triplet<std::complex<double>, long int>*, std::vector<Eigen::Triplet<std::complex<double>, long int>, std::allocator<Eigen::Triplet<std::complex<double>, long int> > > >; SparseMatrixType = Eigen::SparseMatrix<std::complex<double>, 0, long int>; DupFunctor = Eigen::internal::scalar_sum_op<std::complex<double>, std::complex<double> >]
void bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::cube2triCommonEdge(const SCVT*, int, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT&) const [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
void bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::cube2triCommonVertex(const SCVT*, int, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT&) const [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
void bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::cube2triDisjoint(const SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT&) const [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
void bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::cube2triIdentical(const SCVT*, int, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT*, bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::SCVT&) const [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
void bem4i::BEIntegrator<LO, SC, SpecificIntegrator>::getSauterSchwabQuadratureType(LO, LO, int&, int&, int&) const [with LO = long int; SC = std::complex<double>; SpecificIntegrator = bem4i::BEIntegratorHelmholtz<long int, std::complex<double> >]
void bem4i::BEIntegratorHelmholtz<LO, SC>::computeElemMatrix1Layer(LO, LO, bem4i::FullMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::BEIntegratorHelmholtz<LO, SC>::computeElemMatrix1LayerDisjointP0P0(LO, LO, bem4i::FullMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::BEIntegratorHelmholtz<LO, SC>::computeElemMatrix1LayerSauterSchwabP0P0(LO, LO, bem4i::FullMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::BEIntegratorHelmholtz<LO, SC>::computeElemMatrix2Layer(LO, LO, bem4i::FullMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::BEIntegratorHelmholtz<LO, SC>::computeElemMatrix2LayerDisjointP0P1(LO, LO, bem4i::FullMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::BEIntegratorHelmholtz<LO, SC>::computeElemMatrix2LayerSauterSchwabP0P1(LO, LO, bem4i::FullMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
*computeElemMatrix*
*areElementsDisjoint*
void bem4i::FullMatrix<LO2, SC2>::LUSolve(bem4i::Vector<LO, SC>&, LO) [with LO = long int; SC = double]
void bem4i::FullMatrix<LO2, SC2>::apply(const bem4i::Vector<LO, SC>&, bem4i::Vector<LO, SC>&, bool, SC, SC) [with LO = long int; SC = std::complex<double>]
void bem4i::FullMatrix<LO2, SC2>::backward(bem4i::Vector<LO, SC>&, LO, LO) [with LO = long int; SC = std::complex<double>]
void bem4i::FullMatrix<LO2, SC2>::getCol(LO, SC*) const [with LO = long int; SC = std::complex<double>]
void bem4i::FullMatrix<LO2, SC2>::resize(LO, LO, bool) [with LO = long int; SC = std::complex<double>]
void bem4i::FullMatrix<LO2, SC2>::scale(SC) [with LO = long int; SC = std::complex<double>]
void bem4i::IdentityOperator<LO3, SC3>::apply(const bem4i::Vector<LO, SC>&, bem4i::Vector<LO, SC>&, bool, SC, SC) [with LO = long int; SC = std::complex<double>]
void bem4i::IdentityOperator<LO3, SC3>::applyP0P1(const bem4i::Vector<LO, SC>&, bem4i::Vector<LO, SC>&, bool, SC, SC) [with LO = long int; SC = std::complex<double>]
void bem4i::IdentityOperator<LO3, SC3>::assemble(bem4i::SparseMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::IdentityOperator<LO3, SC3>::assembleP1P1(bem4i::SparseMatrix<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::SparseMatrix<LO, SC, storage>::apply(const bem4i::Vector<LO, SC>&, bem4i::Vector<LO, SC>&, bool, SC, SC) [with LO = long int; SC = std::complex<double>; int storage = 0]
void bem4i::SparseMatrix<LO, SC, storage>::setFromTriplets(LO, LO, std::vector<LO>&, std::vector<LO>&, std::vector<SC>&) [with LO = long int; SC = std::complex<double>; int storage = 0]
void bem4i::SurfaceMesh3D<LO, SC>::getLocalCoordinates(const SCVT*, const SCVT*, const SCVT*, bem4i::SurfaceMesh3D<LO, SC>::SCVT*, bem4i::SurfaceMesh3D<LO, SC>::SCVT*, bem4i::SurfaceMesh3D<LO, SC>::SCVT*, bem4i::SurfaceMesh3D<LO, SC>::SCVT*, bem4i::SurfaceMesh3D<LO, SC>::SCVT*) const [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::getQuadratureNodes(const SCVT*, const SCVT*, const SCVT*, bem4i::SurfaceMesh3D<LO, SC>::SCVT*, int) const [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::initArea() [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::initEdges() [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::initL2g() [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::initLocalCoordinates() [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::initNode2Elems() [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::printInfo() [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::refine(int, int) [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::refine_2sect(int) [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::refine_3sect(int) [with LO = long int; SC = std::complex<double>]
void bem4i::Vector<LO, SC>::add(const bem4i::Vector<LO, SC>&, SC) [with LO = long int; SC = std::complex<double>]
void bem4i::Vector<LO, SC>::add(const bem4i::Vector<LO, SC>&, bem4i::Vector<LO, SC>&, SC) [with LO = long int; SC = double]
void bem4i::Vector<LO, SC>::add(const bem4i::Vector<LO, SC>&, bem4i::Vector<LO, SC>&, SC) [with LO = long int; SC = std::complex<double>]
void bem4i::Vector<LO, SC>::copy(bem4i::Vector<LO, SC>&) const [with LO = long int; SC = std::complex<double>]
void bem4i::Vector<LO, SC>::cross(const bem4i::Vector<LO, SC>&, bem4i::Vector<LO, SC>&, LO) const [with LO = long int; SC = double]
void bem4i::Vector<LO, SC>::scale(SC) [with LO = long int; SC = double]
void bem4i::Vector<LO, SC>::scale(SC) [with LO = long int; SC = std::complex<double>]
void intro()
void printLogo()
bool bem4i::SurfaceMesh3D<LO, SC>::load(const string&, bem4i::SurfaceMesh3D<LO, SC>::SCVT) [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::initCurl() [with LO = long int; SC = std::complex<double>]
void bem4i::SurfaceMesh3D<LO, SC>::initNormals() [with LO = long int; SC = std::complex<double>]
SCOREP_REGION_NAMES_END
